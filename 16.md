---
title: 📓 資料② | Python 入門
---

最近は、コーディング（プログラミングコードを書くこと）の支援に Gemini のような生成 AI を利用することが多くなっています。例えば、AIに「モル濃度を計算するコードを作って」と依頼すれば、それらしいコードが瞬時に生成されます。

![photo](https://gyazo.com/5279f561521b42fbbdb5d4f0aef47928.png)

しかし、そのコードが期待通りに動かない場合（例：ユーザーが入力した「質量」を数値として扱えずエラーになる）、AIのコードを「デバッグ（修正）」する必要があります。このデバッグには、「なぜエラーが起きたのか」（例：データ型が違う）を理解する「文法知識」が不可欠です。

この章では、AIを「何でもこなしてくれる万能なプログラマー」として盲信するのではなく、「（時々間違える）有能なアシスタント」として頼りにするための「**AIリテラシー**」を学びます。

具体的には、AIが生成したコードを見て、「ここは **list** を使っているが、 **dictionary** の方が適切だ」と判断できるようになることを目指します。

## Pythonプログラミングの基本要素：変数とデータ型

この節では、データ（情報）をコンピュータに記憶させるための最も基本的な概念である「変数」と、データの種類を区別する「データ型」を学んでいきましょう。

### 変数 (Variable) とは：データに「ラベル」を貼る

**変数** (Variable) とは、データ（数値や文字列など）を格納するための「名前付きの箱」です。化学実験で、サンプルを入れたバイアル瓶に「Sample A (pH 7.0)」とラベルを貼る行為に似ています。

コードセルで `=` （等号）を使うと、右側の値を左側の名前の変数に格納できます。この操作を **代入** (Assignment) と呼びます。

#### Colabで実践:

```python
# 水素の原子量を 'atomic_mass_H' という名前の変数に代入する
atomic_mass_H = 1.008

# 炭素の元素名を 'element_name_C' という変数に代入する
element_name_C = "Carbon"

# print() 関数は、変数の中身を表示する
print(atomic_mass_H)
print(element_name_C)
```

**実行結果:**

```term
1.008
Carbon
```

### 数値、文字列、真偽値：化学データ表現の基礎

**データ型** (Data Type) とは、コンピュータがそのデータ（例：6と "Carbon"）をどう扱うべきかを決めるための「種類」です。 **type()** 関数を使うと、変数のデータ型を確認できます。化学データを扱う上で、まず以下の4つの基本データ型を覚える必要があります。

#### int（整数 / Integer）

小数を含まない数値です。化学では、原子番号、電子の数、分子内の原子数（例：H$_2$Oの2）など、カウント可能なものを表すのに使います。

```python
atomic_number = 6
print(type(atomic_number))
```

**実行結果:**

```term
<class 'int'>
```

#### float（浮動小数点数 / Floating Point Number）

小数を含む数値です。化学では、原子量、分子量、質量、温度、pHなど、測定値や計算結果のほとんどを表すのに使います。

```python
atomic_mass = 12.011
ph_value = 7.0
print(type(atomic_mass))
```

**実行結果:**

```term
<class 'float'>
```

#### str（文字列 / String）

テキストデータです。`"` （ダブルクォート）または `'` （シングルクォート）で囲みます。化学では、元素名、化学式、SMILES記法などを表すのに使います。

```python
element_symbol = "Fe"
chemical_formula = "C6H12O6"
print(type(chemical_formula))
```

**実行結果:**

```term
<class 'str'>
```

#### bool（ブール値、真偽値 / Boolean）

**True** （真）か **False** （偽）の2つの値しか持たない、特殊なデータ型です。化学では、条件の判定結果（例：この溶液は酸性か？）を表すのに使います。

```python
is_acidic = ph_value < 7.0  # ph_value は 7.0 なので、この判定結果は False になる
print(is_acidic)
print(type(is_acidic))
```

**実行結果:**

```term
False
<class 'bool'>
```

## 算術演算子と比較演算子：化学計算の基本

この節では、変数に格納したデータを使って化学計算を行うための「演算子」を学んでいきましょう。

### 算術演算子：Pythonを化学計算機として使う

Pythonは、基本的な算術演算子（計算記号）を備えているので、もちろん、高機能な電卓としても機能します。

- `+` （足し算）
- `-` （引き算）
- `*` （掛け算）
- `/` （割り算）
- `**` （べき乗、例：`10**-7` は $10^{-7}$ を意味します）
- `()` （括弧、計算順序の指定）

#### Colabで実践：水の分子量の計算

前節で学んだ変数を使い、水の分子量（g/mol）を計算してみましょう。この計算のロジックは、多くのプログラムの基礎となります。

```python
# 主要元素の原子量（g/mol）を変数に格納
atomic_mass_H = 1.008
atomic_mass_O = 15.999

# 水 (H2O) の分子量を計算
# 括弧()を使って、足し算より掛け算が先に行われることを明示する
mw_water = (atomic_mass_H * 2) + atomic_mass_O

# f-string (f"...") を使うと、{変数名} の部分に自動で値が挿入され便利
print(f"水の分子量 (H2O): {mw_water} g/mol")
```

**実行結果:**

```term
水の分子量 (H2O): 18.015 g/mol
```

### 比較演算子と論理演算子：条件を記述する

次に、値を比較し、 **True** か **False** のブール値（前節）を返す演算子を学びます。これらは、プログラムに「判断」をさせる（後述の **if** 文）ために不可欠です。

#### 比較演算子

- `==` （等しい、 `=` 1つは代入なので注意）
- `!=` （等しくない）
- `<` （より小さい）、`<=` （以下）
- `>` （より大きい）、`>=` （以上）

#### 論理演算子

- **and** （A **かつ** B の両方が **True** の場合のみ **True** ）
- **or** （A **または** B のどちらかが **True** なら **True** ）
- **not** （ **True** と **False** を反転させる）

#### Colabで実践：pH値に基づく溶液の分類

後述の **if** 文の「判定材料」として、これらの演算子を使ってみましょう。

```python
ph = 4.5

# 比較演算子で条件を判定
is_acidic = ph < 7.0
is_basic = ph > 7.0

print(f"pH {ph} は酸性ですか？ {is_acidic}")
print(f"pH {ph} は塩基性ですか？ {is_basic}")

# 論理演算子で複雑な条件を判定（例：中性に近い弱酸性）
# 「pHが5.0以上」かつ「pHが7.0未満」
is_weak_acid = (ph >= 5.0) and (ph < 7.0)

print(f"pH {ph} は弱酸性（5.0以上7.0未満）ですか？ {is_weak_acid}")
```

**実行結果:**

```term
pH 4.5 は酸性ですか？ True
pH 4.5 は塩基性ですか？ False
pH 4.5 は弱酸性（5.0以上7.0未満）ですか？ False
```

## リスト：元素周期表や反応物リストの管理

この節から、複数のデータをまとめて扱う「コレクション」を学びます。最初は、最も汎用的な「リスト」です。

### リスト (List) とは：順序があり、変更可能なデータの集まり

**リスト** (List) とは、複数のデータを「順序を保って」格納するコレクションです。 `[]` （角括弧）で作成します。

リストの最大の特徴は、データは後から自由に追加、変更、削除が可能なこと（**Mutable**、可変）です。

- 化学での応用（1）：元素周期表の管理

```python
elements_period1_2 = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne']
```

- 化学での応用（2）：実験データの時系列

```python
reaction_concentrations = [1.0, 0.85, 0.72, 0.61, 0.50]` # 0分後, 1分後, 2分後...
```
 
- 化学での応用（3）：反応物リスト

```python
reactants = ['CH4', 'O2']
```

### リストの操作：インデックス指定とスライシング

リストは「順序」を持つため、番号で要素を指定できます。

-   **インデックス指定** (Indexing): 要素を取り出します。**注意：Pythonの順序は常に 0 から始まります。**
-   **スライシング** (Slicing): 範囲を指定して、リストの一部を新しいリストとして「切り出し」ます。

#### Colabで実践:

```python
elements = ['H', 'He', 'Li', 'Be', 'B', 'C', 'O']

# インデックス指定： 0番目（最初）の要素
print(f"0番目の元素: {elements[0]}")

# インデックス指定： 2番目（3つ目）の要素
print(f"2番目の元素: {elements[2]}")

# スライシング： 2番目から5番目の直前まで (2, 3, 4番目)
print(f"2番目から4番目: {elements[2:5]}")

# リストの変更 (Mutable)
# 末尾に 'N' を追加
elements.append('N')
print(f"追加後: {elements}")

# 1番目の 'He' を 'Helium' (文字列) に変更
elements[1] = 'Helium'
print(f"変更後: {elements}")

# len() 関数でリストの長さ（要素数）を取得
print(f"現在の要素数: {len(elements)}")
```

**実行結果:**

```term
0番目の元素: H
2番目の元素: Li
2番目から4番目: ['Li', 'Be', 'B']
追加後: ['H', 'He', 'Li', 'Be', 'B', 'C', 'O', 'N']
変更後: ['H', 'Helium', 'Li', 'Be', 'B', 'C', 'O', 'N']
現在の要素数: 8
```

## タプルとセット：不変なデータと重複のないコレクション

この節では、リストと似ていますが、特定の目的（不変性、重複排除）に特化したコレクションを学びます。

### タプル (Tuple) とは：順序があるが、「変更不可能（Immutable）」なコレクション

**タプル** (Tuple) はリストとほぼ同じですが、 `()` （丸括弧）で作成し、一度作成すると要素の変更や追加が一切できません（**Immutable**、不変）。

#### Colabで実践：不変なデータ（物理定数、座標）の管理

化学の計算では、たとえば、気体定数 $R$ やアボガドロ定数 $N_A$ のような、プログラムの実行中に絶対に変更されてはならない「物理定数」にタプルを使うことができます。

```python
# (気体定数 R, アボガドロ定数 NA)
FUNDAMENTAL_CONSTANTS = (8.314, 6.022e23)

print(f"気体定数 R: {FUNDAMENTAL_CONSTANTS[0]}")
print(f"アボガドロ定数 NA: {FUNDAMENTAL_CONSTANTS[1]}")

# FUNDAMENTAL_CONSTANTS.append(9.8) # この行を実行するとエラーになる
# FUNDAMENTAL_CONSTANTS[0] = 1.0     # この行を実行するとエラーになる
```

**実行結果:**

```term
気体定数 R: 8.314
アボガドロ定数 NA: 6.022e+23
```

### セット (Set) とは：順序がなく、「重複のない」コレクション

**セット** (Set) は、順序の概念がなく、重複する要素を自動的に排除するユニークなコレクションです。 `{}` （波括弧）または **set()** 関数で作成します。

#### Colabで実践:化学式に含まれる「ユニークな」元素を特定する

実験データや化学式を扱っていると、「このサンプルに含まれる化学種は、全部で何種類あるか？」を知りたくなることがあります。セットは、この「重複排除」を自動で行います。

```python
# アスパラギン酸 (C4H7NO4) を構成する全原子の「リスト」
# このリストは長大で、何種類の元素があるか一目でわかりにくい
atoms_list = ['C', 'C', 'C', 'C', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'N', 'O', 'O', 'O', 'O']

print(f"原子の総数 (リスト): {len(atoms_list)}")

# set() 関数にリストを渡すだけで、重複が自動的に削除される
unique_elements = set(atoms_list)

print(f"含まれる元素の種類 (セット): {unique_elements}")
print(f"元素の種類数: {len(unique_elements)}")
```

**実行結果:**

```term
原子の総数 (リスト): 16
含まれる元素の種類 (セット): {'O', 'H', 'N', 'C'}
元素の種類数: 4
```

`{}` の出力順序は実行ごとに変わる可能性があることに注意してください。セットにはリストのような「0番目」という概念が存在しません。

## 辞書：分子の物性値や反応条件の整理

この節では、化学データを扱う上で最も重要と言えるデータ構造、「辞書」を学びます。

### 辞書 (Dictionary) とは：「キー」と「値」のペアで管理するコレクション

**辞書** (Dictionary) は、リストが `[]` という「順序（インデックス）」でデータを管理するのに対し、「名前（キー）」でデータを管理するコレクションです。

`{キー: 値}` の形式で作成し、キーと値がペアになっています。英和辞書で「Apple」（キー）を引くと「リンゴ」（値）が出てくるのと同じです。

#### Colabで実践:原子量辞書（マッピング）

辞書は、化学データを「マッピング（対応付け）」するのに最適です。例えば、「元素記号（キー）」と「原子量（値）」をマッピングします。

```python
# 元素記号(キー)と原子量(値)をマッピングする辞書
atomic_masses = {
    "H": 1.008,
    "C": 12.011,
    "O": 15.999,
    "N": 14.007,
    "Fe": 55.845
}

# キー 'C' を指定して、対応する値を取得
print(f"炭素の原子量: {atomic_masses['C']}")

# 新しいキーと値を追加
atomic_masses['Cl'] = 35.453
print(f"塩素の原子量: {atomic_masses['Cl']}")

# 'in' 演算子で、キーが存在するか確認
print(f"'Fe' は辞書に存在しますか？ {'Fe' in atomic_masses}")
print(f"'Ca' は辞書に存在しますか？ {'Ca' in atomic_masses}")
```

**実行結果:**

```term
炭素の原子量: 12.011
塩素の原子量: 35.453
'Fe' は辞書に存在しますか？ True
'Ca' は辞書に存在しますか？ False
```

辞書の値には、数値や文字列だけでなく、リスト（前述）や、さらに別の辞書（ネスト）も格納できます。これにより、複雑なデータを体系的に整理できます。物性データベースや反応データベースは、本質的にこの辞書構造の集まりです。

#### Colabで実践:分子の物性値や反応条件の整理

```python
# ベンゼンの物性値を辞書で管理
benzene_properties = {
    "formula": "C6H6",
    "mw": 78.11,
    "melting_point_C": 5.5,
    "boiling_point_C": 80.1,
    "density_g_mL": 0.876
}

print(f"ベンゼンの沸点: {benzene_properties['boiling_point_C']} ℃")

# 反応条件を辞書で管理
reaction_conditions = {
    "temperature": 100,      # 単位は別途定義（例：'unit': 'C'）
    "pressure": 1,           # atm
    "catalyst": "Pd/C",
    "solvents": ['Water', 'Methanol'] # 値にリストを使用
}

# ネストされたリストの2番目の要素（インデックスは1）にアクセス
print(f"使用する溶媒（2番目）: {reaction_conditions['solvents'][1]}")
```

**実行結果:**

```term
ベンゼンの沸点: 80.1 ℃
使用する溶媒（2番目）: Methanol
```

### 表1：Pythonの主要コレクション比較

この章の「AIリテラシー」という目標では、AIが生成したコードが `[]` 、 `()` 、 `{}` のどれを使っているかを理解することは重要です。以下の表は、データ構造を選ぶための「チートシート」です。

| 特徴  | リスト (List)       | タプル (Tuple)         | セット (Set)   | 辞書 (Dictionary)    |
| :-- | :--------------- | :------------------ | :---------- | :----------------- |
| 構文  | `[1, 2, 3]`      | `(1, 2, 3)`         | `{1, 2, 3}` | `{'a': 1, 'b': 2}` |
| 順序  | **あり**           | **あり**              | なし          | なし                 |
| 変更  | **可能 (Mutable)** | **不可能 (Immutable)** | 可能          | 可能                 |
| 重複  | 可能               | 可能                  | **不可能**     | キーは不可能             |

AIが原子量マップをリストで作成してきたら、この表を見て「キーでアクセスできる辞書が最適だ」と判断して、リスト形式を辞表形式へと修正することもできますね。これが AIリテラシー。

## 条件分岐（if文）：特定の条件に基づく処理の実行

この節では、プログラムに「もし～ならば、～する」という「判断」を行わせる方法を学びます。これにより、状況に応じた自動処理が可能になります。

### if, elif, else：条件に応じた処理の実行

**if** 文（条件分岐）は、指定した条件（前述のブール値、 **True** か **False** ）を評価し、 **True** の場合にのみ特定のコードブロック（処理のかたまり）を実行します。

**構文のポイント：**

1.  **`:` （コロン）:** **if** 、 **elif** 、 **else** の行の終わりには必ずコロンが必要です。
2.  **インデント（字下げ）:** Pythonでは、 **if** 文に属するコードブロックを、**半角スペース4つ** のインデント（字下げ）で示します。このインデントが文法の一部であり、非常に重要です。

```python
if (条件1):
    # インデント（半角スペース4つ）
    # 条件1がTrueの時の処理
elif (条件2):
    # インデント
    # 条件1がFalseで、条件2がTrueの時の処理
else:
    # インデント
    # 全ての条件がFalseの時の処理
```

### Colabで実践：pH値に応じた溶液の分類

前述のpH判定ロジックを、 **if** 文を使って完成させます。これはpH判定の典型的なコードです。

```python
# input() と float() を組み合わせて、ユーザーからpH値を入力してもらう
ph_value = float(input("測定したpH値を入力してください: "))

if ph_value < 7.0:
    print(f"pH {ph_value} は「酸性」です。")

    # if文のネスト（入れ子）
    # 「酸性」であり、かつ「4.0未満」の条件を判定
    if ph_value < 4.0:
        print("（特に強い酸性です）")

elif ph_value > 7.0:
    print(f"pH {ph_value} は「塩基性」です。")

else:
    # 上記の2条件（< 7.0, > 7.0）が両方Falseの場合
    # つまり ph_value == 7.0 と同じ
    print(f"pH {ph_value} は「中性」です。")
```

**実行結果（例：3.5と入力した場合）:**

```term
測定したpH値を入力してください: 3.5
pH 3.5 は「酸性」です。
（特に強い酸性です）
```

## 繰り返し処理（forループ、whileループ）：大量データの効率的な操作

この節では、退屈な反復作業（例：リストに入った100個のデータすべてに同じ計算を行う）をコンピュータに自動実行させる「ループ」を学びます。

### forループ：コレクションの全要素に対する反復処理

**for** ループは、リストや辞書などのコレクションから要素を1つずつ順番に取り出し、全ての要素に対して同じ処理を繰り返します。

#### Colabで実践：化合物リストの分子式を一行ずつ表示

```python
compounds_list = ['H2O', 'NH3', 'CH4', 'C6H12O6']

print("--- 分析対象の化合物 ---")
for compound in compounds_list:
    # 1周目: compound は 'H2O'
    # 2周目: compound は 'NH3'
    # 3周目: compound は 'CH4'
    # 4周目: compound は 'C6H12O6'

    # ここでもインデント（半角スペース4つ）が必須
    print(compound)

print("--- リスト終了 ---")
```

**実行結果:**

```term
--- 分析対象の化合物 ---
H2O
NH3
CH4
C6H12O6
--- リスト終了 ---
```

#### Colabで実践：辞書を使った分子量の一括計算

前述の辞書と **for** ループを組み合わせると、非常に強力な処理が可能です。 **.keys()** メソッドを使うと、辞書のキーだけを順番に取り出すことができます。

```python
# 簡易的な分子量データベース（辞書）
mw_database = {
    "H2O": 18.015,
    "NH3": 17.031,
    "CH4": 16.04,
    "C3H8": 44.1  # プロパン
}

# 辞書のキー（化学式）に対してループを回す
for formula in mw_database.keys():
    # 辞書からキー（formula）を使って値（分子量）を取り出す
    mw = mw_database[formula]
    print(f"化学式: {formula}, 分子量: {mw}")
```

**実行結果:**

```term
化学式: H2O, 分子量: 18.015
化学式: NH3, 分子量: 17.031
化学式: CH4, 分子量: 16.04
化学式: C3H8, 分子量: 44.1
```

### whileループ：特定の条件が満たされるまでの反復処理

**for** ループが「リストの終わりまで」と回数が決まっているのに対し、 **while** ループは「指定した条件が **True** である限り」処理を繰り返します。

化学では、反応シミュレーション（例：濃度が特定の閾値を下回るまで計算を続ける）や、ユーザーが「exit」と入力するまでプログラムを終了しないといった用途で使われます。

#### Colabで実践：一次反応の簡易シミュレーション

```python
concentration = 1.0  # 反応物Aの初期濃度 (mol/L)
time = 0             # 時間 (sec)
half_life = 10       # 半減期 (sec)
decay_rate = 0.5**(1/half_life) # 1秒あたりの残存率 (0.5**(1/10) ≒ 0.933)

# 濃度が初期の10% (0.1 mol/L) を下回るまでシミュレーション
while concentration > 0.1:
    # :.3f は「小数点3桁まで表示」という意味の書式指定
    print(f"時間: {time} sec, 濃度: {concentration:.3f} mol/L")

    # 濃度を更新
    concentration = concentration * decay_rate
    # 時間を更新
    time = time + 1

print(f"--- 終了 (濃度が0.1を下回りました) ---")
print(f"最終時間: {time} sec, 最終濃度: {concentration:.3f} mol/L")
```

**実行結果:**

```term
時間: 0 sec, 濃度: 1.000 mol/L
時間: 1 sec, 濃度: 0.933 mol/L
時間: 2 sec, 濃度: 0.870 mol/L
... (中略)...
時間: 32 sec, 濃度: 0.104 mol/L
時間: 33 sec, 濃度: 0.097 mol/L
--- 終了 (濃度が0.1を下回りました) ---
最終時間: 34 sec, 最終濃度: 0.097 mol/L
```

**注意点:** **while** ループは、条件設定や `time = time + 1` のような更新処理を間違えると、条件が永遠に **False** にならず「無限ループ」に陥る危険があります。

## 関数：処理をまとめて再利用可能なコードにする

本節では、作成したコードを「再利用可能な部品」としてまとめる「関数」を学びます。これは、プログラムを整理し、AIが生成したコードを解読・修正するためにも必須の技術です。

### 関数 (Function) とは：処理を「名前」でまとめる

**関数** (Function) とは、 **def** （Defineの略）キーワードを使い、一連の処理に名前を付けたものです。

- **引数（ひきすう）:** `()` （括弧）内で、関数が外部から受け取るデータ（材料）を指定します。
- **戻り値（もどりち）:** **return** キーワードを使い、関数が処理した結果（成果物）を外部に返します。

**なぜ関数が必要か？（AIリテラシー）**

AIに「 $C_1V_1 = C_2V_2$ の計算を」と頼むと、前述のような、 **input()** が散らばった「使い捨て」のスクリプトを生成しがちです。これでは、別の濃度で再計算したい場合、プログラム全体をコピペして書き直さねばならず、非効率でミスも増えます。

優れたプログラムは、ロジック（計算部分）を「関数」としてカプセル化（部品化）します。これにより、必要な時に「関数名」を呼び出すだけで、何度でも同じ処理を実行できます。

#### Colabで実践：温度変換（C→K）関数

**print()** や **input()** を関数の中に含めず、計算ロジックだけを部品化するのが良い設計です。これは典型的な関数例です。

```python
def celsius_to_kelvin(temp_c):
    """
    摂氏温度(temp_c)をケルビンに変換する関数

    引数:
        temp_c (float): 摂氏温度
    戻り値:
        float: ケルビン温度。ただし絶対零度未満の場合は None を返す。
    """
    # エラーチェック（絶対零度未満は物理的にありえない）
    if temp_c < -273.15:
        print(f"エラー: 温度 {temp_c} ℃ は絶対零度を下回っています")
        return None # エラー時はNone（無）を返す

    # メインのロジック
    temp_k = temp_c + 273.15
    return temp_k

# --- ここからが関数を「呼び出す」コード ---
boiling_point_k = celsius_to_kelvin(100.0)
freezing_point_k = celsius_to_kelvin(0.0)

print(f"水の沸点 (K): {boiling_point_k}")
print(f"水の凝固点 (K): {freezing_point_k}")

# エラーチェックを試す
error_case = celsius_to_kelvin(-300.0)
print(f"エラー: 温度 -300.0 ℃ は絶対零度を下回っています")
print(f"エラーケース: {error_case}")
```

**実行結果:**

```term
水の沸点 (K): 373.15
水の凝固点 (K): 273.15
エラー: 温度 -300.0 ℃ は絶対零度を下回っています
エラーケース: None
```

#### Colabで実践：モル濃度計算関数

化学のルーチン計算こそ、関数化すべきですね。

```python
def calculate_molarity(mass_g, mw_g_mol, volume_L):
    """
    質量(g)、分子量(g/mol)、体積(L)からモル濃度(mol/L)を計算する。
    """

    # Step 1: モル数を計算
    moles = mass_g / mw_g_mol

    # Step 2: モル濃度を計算
    # 体積が0でないかチェックする（ゼロ除算エラーを防ぐ）
    if volume_L <= 0:
        print("エラー: 体積は0より大きい値でなければなりません")
        return None

    molarity = moles / volume_L

    return molarity

# --- 関数を呼び出す ---
# 例：NaCl (分子量 58.44 g/mol) を 58.44 g とり、水に溶かして 1.0 L にした場合
mw_nacl = 58.44
molarity_nacl = calculate_molarity(mass_g=58.44, mw_g_mol=mw_nacl, volume_L=1.0)

print(f"NaCl溶液のモル濃度: {molarity_nacl:.2f} M") # :.2f は小数点2桁で表示

# 例：グルコース (分子量 180.16 g/mol) を 18.0 g とり、0.5 L に溶かした場合
mw_glucose = 180.16
molarity_glucose = calculate_molarity(mass_g=18.0, mw_g_mol=mw_glucose, volume_L=0.5)

print(f"グルコース溶液のモル濃度: {molarity_glucose:.2f} M")
```

**実行結果:**

```term
NaCl溶液のモル濃度: 1.00 M
グルコース溶液のモル濃度: 0.20 M
```

このように、AIが生成した長いコードも、機能単位（例：モル数計算、モル濃度計算）で関数に分割（リファクタリング）することで、見通しが良くなり、デバッグが容易になります。

## NumPyの紹介：高速な数値計算のための配列操作

この章の最後として、Pythonの基本機能を拡張し、科学技術計算（特に大量の数値データ処理）を高速に行うための「ライブラリ」である **NumPy** を紹介します。

### ライブラリ (Library) とは：便利なツールの詰め合わせ

**ライブラリ** (Library) とは、Python本体には含まれていない、特定の目的（例：数値計算、データ分析、グラフ描画）のための「追加機能パッケージ」です。

世界中の開発者が作った便利なツール（関数など）の詰め合わせであり、 **import** （輸入）文を使って読み込むことで、自分のプログラムで使えるようになります。

### NumPy (Numerical Python) とは

**NumPy** (Numerical Python) は、高速な数値計算を行うための、Python科学技術計算における最も基本的かつ重要なライブラリです。

#### Colabで実践（import）:

NumPyは非常に有名で頻繁に使われるため、 **np** という愛称（エイリアス）で **import** するのが世界標準の慣習です。

```python
# 'numpy' ライブラリを 'np' という名前で import する
import numpy as np
```

### NumPy配列 (np.array)：Pythonリストとの違い

NumPyの中心的な機能は、 **np.array** という、高速な計算に特化した特別な配列（データの集まり）です。

#### Colabで実践：実験データの格納

Pythonの標準リストを **np.array()** に渡すだけで、NumPy配列を作成できます。滴定データや反応速度データなど、大量の数値はすべてNumPy配列で扱います。

```python
# Pythonの標準リスト
melting_points_list = [98.5, 99.9, 100.6, 99.3, 100.7]

# PythonリストからNumPy配列を作成
melting_points_array = np.array(melting_points_list)

print(f"Pythonリスト: {melting_points_list}")
print(f"NumPy配列:    {melting_points_array}")
print(f"NumPy配列の型: {type(melting_points_array)}")
```

**実行結果:**

```term
Pythonリスト: [98.5, 99.9, 100.6, 99.3, 100.7]
NumPy配列:    [ 98.5  99.9 100.6  99.3 100.7]
NumPy配列の型: <class 'numpy.ndarray'>
```

### NumPyの真価：ベクトル化 (Vectorization)

NumPyの最大の利点は、 **for** ループ（前述）を使わずに、配列全体に対して一度に計算（ブロードキャスティング）できることです。この操作を **ベクトル化** (Vectorization) と呼びます。

#### Colabで実践（リスト vs NumPy配列）：

課題： `melting_points_list` （摂氏）の全要素をケルビン（+273.15）に変換したい。

```python
# (1) Pythonリストの場合（遅い・煩雑）
# `for`ループを使って、1要素ずつ計算し、新しいリストに追加する必要がある
kelvin_list = []
for temp in melting_points_list:
    kelvin_list.append(temp + 273.15)

print(f"リスト (forループ): {kelvin_list}")

# (2) NumPy配列の場合（高速・簡潔）
# `for`ループは不要！ 配列全体に直接 + 273.15 を行うだけ
kelvin_array = melting_points_array + 273.15

print(f"NumPy (ベクトル化): {kelvin_array}")
```

**実行結果:**

```term
リスト (forループ): [371.65, 373.05, 373.75, 372.45, 373.85]
NumPy (ベクトル化): [371.65 373.05 373.75 372.45 373.85]
```

#### Colabで実践：実験データの統計処理

NumPyは、平均値、標準偏差、最大値、最小値など、実験データ分析に必須の統計関数を標準装備しています。

```python
# 5回の滴定実験の結果 (mL)
titration_data = np.array([10.1, 10.3, 9.9, 10.2, 9.8])

# 平均値
mean_volume = np.mean(titration_data)

# 標準偏差
# ddof=1 は統計学的な「不偏標準偏差」を計算するための指定
std_dev = np.std(titration_data, ddof=1)

print(f"滴定データ: {titration_data}")
print(f"平均値: {mean_volume:.3f} mL")
print(f"標準偏差: {std_dev:.3f} mL")
print(f"最大値: {np.max(titration_data)} mL")
```

**実行結果:**

```term
滴定データ: [10.1 10.3  9.9 10.2  9.8]
平均値: 10.060 mL
標準偏差: 0.207 mL
最大値: 10.3 mL
```

**for** ループや複雑な計算式を一切書くことなく、実験データの基本統計量を瞬時に計算できました。これが NumPyの力です。
