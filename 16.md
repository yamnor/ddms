---
title: 📓 付録③ | GPAW 入門
---

この章では、本講座の「データ生成エンジン」として採用している Python ライブラリ **GPAW** について、その機能と基本的な使い方を解説します。

## GPAW とは

**GPAW** (Grid-based Projector Augmented Wave) は、密度汎関数理論 (DFT) に基づく電子状態計算コードです。Python で記述されており、ASE (Atomic Simulation Environment) と組み合わせて使用することで、柔軟かつ直感的に原子・分子シミュレーションを行うことができます。

最大の特徴は、ユーザーが Python スクリプトの中で「計算設定（モードや汎関数など）」をオブジェクトとして定義し、それを原子モデル（`Atoms`）に取り付けるだけで計算が走るという、モダンなインターフェースを持っている点です。

## 計算モード (`mode`)

GPAW は、波動関数をどのように表現するかによって、主に3つの計算モードを持っています。目的に応じて使い分けることが重要です。

### PW (Plane Wave: 平面波基底)

- **概要**: 結晶のような周期的な系を、波（sin / cos）の重ね合わせで表現します。固体物理の分野で最も標準的な手法です。
- **制御パラメータ**: `ecut` (カットオフエネルギー)。
- **メリット**: 精度が `ecut` という1つのパラメータで制御でき、収束性の確認が容易です。
- **本講座での推奨**: **シリコン結晶の計算にはこのモードを使用します。**

```python
from gpaw import GPAW, PW
# カットオフ 400 eV の平面波モード
mode = PW(400)
```

### FD (Finite Difference: 実空間差分)

- **概要**: 空間をグリッド（網の目）に区切り、各点での値を計算します。
- **制御パラメータ**: `h` (グリッド間隔)。
- **メリット**: 孤立した分子や、帯電した系の計算に向いています。
- **注意点**: 本講座の対象であるバルク（結晶）計算では、PWモードの方が計算効率や収束性の面で有利な場合が多いです。

### LCAO (Linear Combination of Atomic Orbitals)

- **概要**: 原子の周りの電子軌道（s軌道、p軌道など）を基底として使います。
- **メリット**: 計算が非常に高速です。原子数が数百〜数千個になるような大規模な系に適しています。
- **デメリット**: 基底関数の選び方に精度が依存するため、PWモードのような系統的な精度向上が難しい場合があります。

## 交換相関汎関数 (`xc`)

DFT 計算では、電子同士の相互作用を近似するための「汎関数（Functional）」を選ぶ必要があります。GPAW は `libxc` ライブラリを利用しており、一般的な汎関数をキーワードで指定できます。

### LDA (局所密度近似)

- `xc='LDA'`: 最も単純な近似。計算コストが低く、構造や振動特性が良い精度で得られることも多いですが、結合エネルギーを過大評価（結合長を短めに評価）する傾向があります。

### GGA (一般化勾配近似)

電子密度の勾配まで考慮した近似です。固体の計算で広く使われています。
- `xc='PBE'`: (Perdew-Burke-Ernzerhof) **現在の標準的な汎関数**です。多くの固体系で妥当な結果を与えます。本講座では一貫してこれを使用します。
- `xc='revPBE'`: (Revised PBE) PBE のパラメータを調整し、原子化エネルギーなどの記述を改善したものです。
- `xc='RPBE'`: (Revised revPBE) 吸着エネルギーの過大評価を修正するために開発されたもので、表面科学の分野でよく使われます。

### Hybrid (ハイブリッド汎関数)

DFT の交換項の一部を、ハートリー・フォック法の正確な交換項で置き換えたものです。精度は高いですが、計算コストは非常に高くなります。
- `xc='PBE0'`: PBE に 25% の正確な交換項を混ぜたものです。
- `xc='B3LYP'`: 量子化学（分子計算）の分野でデファクトスタンダードとして使われている有名な汎関数です。

Colab 上での演習や、一般的な構造最適化・エネルギー計算には、計算コストと精度のバランスが良い **`xc='PBE'`** を推奨します。
{.note}

## 一般的なコードの書き方

Google Colab 上で GPAW を動かす際の、最も標準的なコードのテンプレートです。

```python
from ase.build import bulk
from gpaw import GPAW, PW

# 1. 物質（Atoms）の用意
#    ここではシリコンのダイヤモンド構造を作成
si = bulk('Si', 'diamond', a=5.43)

# 2. 計算機（Calculator）の設定
#    ここが「データ生成装置」の設定パネルに相当します
calc = GPAW(mode=PW(400),       # 計算モード: 平面波, カットオフ400eV
            xc='PBE',           # 汎関数: PBE
            kpts=(4, 4, 4),     # k点: 4x4x4 のメッシュ
            txt='si_calc.txt')  # 出力先: ファイルに保存

# 3. 計算機を物質に取り付ける
si.calc = calc

# 4. 計算の実行（エネルギーを求める）
#    この瞬間に計算が走り出します
energy = si.get_potential_energy()

print(f"Total Energy: {energy:.3f} eV")
```

**出力結果**

```term
Total Energy: -10.789 eV
```

### パラメータの解説

- **`mode=PW(ecut)`**:
    - `ecut` (eV単位) を大きくすると精度が上がりますが、計算時間は長くなります。前述の「収束テスト」で適切な値を決めます。
- **`kpts=(Nx, Ny, Nz)`**:
    - k空間の分割数です。金属では細かく（数を多く）、絶縁体では粗く（数を少なく）ても良い傾向があります。
    - `kpts={'size': (4, 4, 4), 'gamma': True}` と書くと、原点（$\Gamma$点）を含むグリッド生成を指定できます。
- **`txt`**:
    - 計算のログ（途中経過や詳細な結果）の出力先です。
    - `'filename.txt'`: 指定したファイルに保存します（推奨）。
    - `'-'`: 標準出力（画面）に表示します。Colab でこれをやるとログが長くなりすぎて見づらくなることがあるため、ファイル保存がおすすめです。
    - `None`: ログを出力しません。

## Google Colab での注意点

- **計算リソース**: GPAW の計算（特に PW モード）は CPU を集中的に使用します。Colab の無料枠（2コア程度）でも、原子数が少ない単胞（Primitive cell）の計算なら数秒〜数十秒で終わりますが、スーパーセル（原子数を増やした箱）にすると数分〜数十分かかることがあります。
- **ファイルの確認**: `txt='si_calc.txt'` で出力したログファイルは、Colab の左サイドバーにあるフォルダアイコンから確認・ダウンロードできます。計算が正しく収束したか、どのようなパラメータで計算されたかが記録されています。

## 計算できる物性値の例

GPAW は、単にエネルギーを計算するだけでなく、様々な物理量やスペクトルを算出することができます。以下に、代表的な物性値と、それを **Google Colab 上で実際に実行して確認できる具体的なコード例** を紹介します。

### 最適構造（Optimum Structure）

実習では、格子定数を手動で変化させてエネルギーの最小点を探しました（スキャン法）。しかし、原子数が数十〜数百個になり、変数が多数になる複雑な系では、総当たり的なスキャンは不可能です。

`GPAW` では、原子の配置を自動的に最適化して、安定構造（エネルギーが最小になる配置）を探索することができます。

```python
from ase.build import bulk
from gpaw import GPAW, PW
from ase.optimize import BFGS
from ase.filters import UnitCellFilter # Import UnitCellFilter from ase.filters
import numpy as np

# 1. 初期構造の用意（格子定数は任意の値からスタート可能）
si = bulk('Si', 'diamond', a=5.0)

# 2. 計算機の設定
calc = GPAW(mode=PW(350), xc='PBE', kpts=(4, 4, 4), txt='si_opt.txt')
si.calc = calc

# 3. UnitCellFilter を適用してセルも最適化できるようにする
#    これにより、格子定数も最適化の対象となる
ucf = UnitCellFilter(si)

# 4. BFGSオプティマイザを設定 (UnitCellFilterを渡す)
optimizer = BFGS(ucf, logfile='opt.log')

# 5. 構造最適化の実行
optimizer.run(fmax=0.05)

# 6. 最適化後の結果を確認
print(f"Optimized lattice constant: {si.cell.lengths()[0] * np.sqrt(2):.3f} Å")
print(f"Total energy: {si.get_potential_energy():.3f} eV")
```

**出力例：**
```term
Optimized lattice constant: 5.473 Å
Total energy: -10.795 eV
```

### バンド構造 (Band Structure)

電子が結晶内でどのようなエネルギー準位を取りうるか（バンド図）を描きます。半導体のバンドギャップなどを確認する基本解析です。

```python
from ase.build import bulk
from gpaw import GPAW, PW, FermiDirac

# 1. 基底状態計算
#    まず通常のSCF計算を実行し、結果を保存します
si = bulk('Si', 'diamond', 5.43)
calc = GPAW(mode=PW(200),
            xc='PBE',
            kpts=(8, 8, 8),
            random=True,  # random guess (needed if many empty bands required)
            occupations=FermiDirac(0.01),
            txt='Si_gs.txt')
si.calc = calc
si.get_potential_energy()
ef = calc.get_fermi_level()
calc.write('Si_gs.gpw')  # 計算結果を保存

# 2. バンド構造計算用の設定に変更
#    保存したファイルから再起動し、fixed_density()でバンド構造計算用の設定に変更
calc = GPAW('Si_gs.gpw').fixed_density(
    nbands=16,
    symmetry='off',
    kpts={'path': 'GXWKL', 'npoints': 60},
    convergence={'bands': 8})

# 3. バンド構造の計算とプロット
bs = calc.band_structure()
bs.plot(filename='bandstructure.png', show=True, emax=10.0)
```

**出力結果**

![](https://gyazo.com/306f3f1a5aee97f158d6e4f4d2cd52bd.png)

### 状態密度 (DOS: Density of States)

あるエネルギー準位に、どれくらいの数の電子が存在できるかを示す分布図です。

```python
from ase.build import bulk
from gpaw import GPAW, PW
import matplotlib.pyplot as plt

# 1. 計算実行
#    DOSをきれいに描くには、k点を多めにとるのがコツです
si = bulk('Si', 'diamond', a=5.43)
calc = GPAW(mode=PW(300), xc='PBE', kpts=(8, 8, 8), txt=None)
si.calc = calc
si.get_potential_energy()

# 2. DOSの取得
e, dos = calc.get_dos(npts=201, width=0.2)
e_f = calc.get_fermi_level()

# 3. プロット
plt.figure()
plt.plot(e - e_f, dos)
plt.xlabel('Energy - Ef (eV)')
plt.ylabel('DOS')
plt.title('Density of States (Si)')
plt.savefig('dos.png')
```

**出力結果**

![](https://gyazo.com/81c5eb32b045bc64c1bfac00ed3d2745.png)

### 光学的性質 (Optical Spectrum)

線形応答時間依存密度汎関数理論（LR-TDDFT）を用いて、物質がどの波長の光を吸収するかをシミュレーションします。

```python
from ase.build import bulk
from gpaw import GPAW, PW
from gpaw.lrtddft import LrTDDFT, photoabsorption_spectrum

# 1. 基底状態計算
#    光学特性の計算には、非占有バンド（空バンド）の情報が必要です
#    nbands=16 で、価電子帯(4つ)に加えて伝導帯(12個)まで計算させます
#    LrTDDFTはGamma点での計算が必要なため、kpts=(1,1,1)を設定
si = bulk('Si', 'diamond', a=5.43)
calc = GPAW(mode='fd', xc='PBE', kpts=(1, 1, 1), nbands=16, txt='Si_opt.txt') # Changed mode from PW(300) to 'fd'
si.calc = calc
si.get_potential_energy()
calc.write('Si_opt.gpw')

# 2. 線形応答TDDFT計算
#    基底状態から再起動してLR-TDDFT計算を実行
calc = GPAW('Si_opt.gpw')
lr = LrTDDFT(calc, xc='LDA', restrict={'istart': 0, 'jend': 16})
lr.write('Si_lrtd.gz')

# 3. 吸収スペクトルの計算
photoabsorption_spectrum(lr, 'Si_absorption.dat', e_min=0.0, e_max=10.0)
```

```python
import numpy as np
import matplotlib.pyplot as plt

# データファイルを読み込む
data = np.loadtxt('Si_absorption.dat')
energy = data[:, 0]
absorption = data[:, 1]

# 吸収スペクトルのプロット
plt.figure(figsize=(8, 6))
plt.plot(energy, absorption, label='Absorption Spectrum')
plt.xlabel('Energy (eV)')
plt.ylabel('Absorption (arbitrary units)')
plt.title('Photoabsorption Spectrum of Silicon (Si)')
plt.grid(True)
plt.legend()
plt.savefig('Si_absorption_spectrum.png')
plt.show()
```

**出力結果**

![](https://gyazo.com/e7064808240c553abee7ef31407caf68.png)
