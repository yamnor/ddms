---
title: 📘 実習② | エネルギーを計算する
---

本章からいよいよ、Python コードを用いた第一原理計算の実習をおこないます。

まずは、最も基本的な **単点エネルギー計算（Single Point Energy Calculation）** を行います。これは、原子の位置を固定した状態で、その構造が持つポテンシャルエネルギーを算出するプロセスです。

## シリコン結晶構造の定義

コンピュータ・シミュレーションでは、はじめに、原子の種類と座標、そして周期境界条件（セルサイズ）を定義することで「デジタルな分子モデル」を作成します。`ASE` には、一般的な結晶構造を簡単に作成できる `bulk` 関数が用意されています。

ここでは `bulk` 関数を用いて、シリコンの **ダイヤモンド構造** を作成します。ダイアモンド構造は、シリコンの最も安定な原子配置の一つです。

```python
from ase.build import bulk
from ase.visualize.plot import plot_atoms
import matplotlib.pyplot as plt

# シリコンのダイヤモンド構造を定義
# 格子定数 a = 5.43 Å （実験値）
atoms = bulk('Si', 'diamond', a=5.43)

# 定義したシリコン結晶構造の確認
print(f"化学式: {atoms.get_chemical_formula()}")
print(f"原子数: {len(atoms)}")
print(f"格子ベクトル (Å): {atoms.get_cell()}")
```

**出力例：**

```term
化学式: Si2
原子数: 2
格子ベクトル (Å): Cell([[0.0, 2.715, 2.715], [2.715, 0.0, 2.715], [2.715, 2.715, 0.0]])
```

ASE には、コンピュータに構築した分子モデルを可視化する機能も備わっています。

分子の立体構造を可視化する際には、`view(atoms, viewer='x3d')` を使うと、Google Colab上でもインタラクティブな3D表示が可能です。また、`matplotlib` を使った静止画での可視化も可能です。

X3Dビューワーを使用する場合は、以下のように記述します：

```python
from ase.visualize import view

# X3Dビューワーで表示（Google Colab上でも動作）
view(atoms, viewer='x3d')
```

**出力例：**

![](https://gyazo.com/551dfa97520d2efb2954b82f78734a3f.png)

```python
# シリコン結晶構造の可視化（matplotlibを使用）
fig, ax = plt.subplots(figsize=(8, 4))
plot_atoms(atoms, ax, radii=0.8, rotation=('45x,45y,0z'))
plt.title('Si Diamond Structure')
plt.axis('equal')
plt.axis('off')
plt.tight_layout()
plt.show()
```

**出力例：**

![](https://gyazo.com/8a969c53d5249674f96dc650970b41b6.png)

## 計算精度の設定：k点とカットオフ

ここで、計算エンジン（GPAW）の精度を決めるパラメータについて簡単に考察してみます。

第一原理計算には、**「精度」と「コスト（時間）」のトレードオフ** を決める2つの重要なパラメータがあります。

| パラメータ            | 表記               | 実験で言うと？        | 物理的な意味は？                                                                                             |
| :--------------- | :--------------- | :------------- | :--------------------------------------------------------------------------------------------------- |
| **カットオフエネルギー**   | $E_{\text{cut}}$ | 顕微鏡の**倍率・分解能** | 電子の波動関数をどれだけ細かく表現するか。値が大きいほど高精度だがコスト高。コード中では `PW(200)` や `PW(350)` の数値が $E_{\text{cut}}$ に対応します。     |
| **k点（k-points）** | $k$              | 測定の**サンプリング数** | 結晶内の電子状態を何点でサンプリングするか。点数が多いほど高精度だがコスト高。コード中では `kpts=(1, 1, 1)` や `kpts=(4, 4, 4)` が $k$ 点メッシュに対応します。 |

![](https://gyazo.com/1befeafc7f9bcd36d1235a8fd64c751e.jpeg)

![](https://gyazo.com/acf087a4159ec6a7887c327900878586.jpeg)

### 考察：低すぎる分解能で計算すると？

ここで、あえて「不適切な設定」で第一原理計算を実行してみます。

**Q. 分解能（カットオフ）とサンプリング数（k点）を極端に下げて計算すると、どうなるでしょうか？**

1. エラーが出て計算が止まる。
2. 計算は終わるが、値がおかしい。
3. 計算が終わらない。

予想してから、以下のコードを実行してみてください。

```python
from gpaw import GPAW, PW

# 意図的に「低品質」な設定で計算
#   カットオフ: 200eV (低すぎる)
#   k点: (1, 1, 1) (ガンマ点のみ、サンプリング不足)
calc_low = GPAW(mode=PW(200),
                xc='PBE',
                kpts=(1, 1, 1))

# 計算機を原子にセット
atoms.set_calculator(calc_low)

# 単点エネルギー計算を実行
energy_low = atoms.get_potential_energy()

print(f"低精度での計算結果: {energy_low:.4f} eV")
```

**出力例:**

```term
低精度での計算結果: 6.2628 eV
```

#### 結果の解説

低精度での計算結果は、物理的に不自然な結果（ポテンシャルエネルギーが正の値になる）になっているはずです。

一般的に、結合した原子系（結晶）のポテンシャルエネルギーは、通常であれば**負の値**になるはずです。これは、原子が結合することで系全体のエネルギーが下がる（安定化する）ことを意味します。

先ほどの計算結果で正の値になったということは、原子が結合していない状態（無限に離れた状態）よりもエネルギーが高いことを示していて、奇妙な結果だと言えます。

したがって Quiz の正解は「**2. 計算は終わるが、値がおかしい**」です。

恐ろしいことに、計算科学のプログラムは、設定が物理的にナンセンスであっても、コードさえ合っていれば文句を言わずに計算してしまいます。

この「サイレントな失敗」を防ぐためには、適切なパラメータ設定の相場観を知っておく必要があります。

### 適切な設定での計算

気を取り直して、実用に耐えうる「標準的な設定」で計算します。

シリコンの場合、以下の設定が今回の実習での推奨値です。

- **カットオフエネルギー**: 350 eV
- **k点**: 4 x 4 x 4

```python
# 適切な設定で単点エネルギー計算を実行
#   カットオフ: 350eV (実用的な精度)
#   k点: (4, 4, 4) (結晶全体をまんべんなくサンプリング)
calc_high = GPAW(mode=PW(350),
                 xc='PBE',
                 kpts=(4, 4, 4))

# 計算機を再セット
atoms.set_calculator(calc_high)

# 再計算（少し時間がかかります）
energy_high = atoms.get_potential_energy()

print(f"適切な設定での計算結果: {energy_high:.4f} eV")
```

**出力例:**

```term
適切な設定での計算結果: -10.7882 eV
```

先ほどと値が変わり、負の値になっているはずです。これが、この条件下におけるシリコン（$a=5.43\text{ \AA}$）の「より適切な」ポテンシャルエネルギーです。

## 手動スキャン：格子定数を変えてみる

物質の性質を知るには、一点のデータだけでは不十分な場合があります。

例えば、シリコンの「硬さ（体積弾性率）」を知るには、格子定数を少し変えて（ひずみを与えて）、エネルギーがどう変化するかを調べる必要があります。

以下のコードの格子定数 `a` を手動で書き換え、何度か実行してエネルギーの変化をメモしてみてください。

```python
# === CHANGE HERE ===========================
# 以下の数値を変更して実行してください
# 例: 5.3, 5.4, 5.5, 5.6 など
current_a = 5.3
# ===========================================

# 新しい格子定数でシリコン結晶構造を作り直す
atoms_scan = bulk('Si', 'diamond', a=current_a)

# 計算機をセット（設定は先ほどの calc_high を使い回します）
atoms_scan.set_calculator(calc_high)

# 単点エネルギー計算を実行
e = atoms_scan.get_potential_energy()
print(f"格子定数 a = {current_a} Å → エネルギー = {e:.4f} eV")
```

**出力例:**

```term
格子定数 a = 5.3 Å → エネルギー = -10.6784 eV
...
格子定数 a = 5.6 Å → エネルギー = -10.7465 eV
```

### 手動作業の限界

数回やってみると分かりますが、これを10点、20点と手動で繰り返してグラフを描くのは非常に手間がかかります。また、転記ミスしてしまうかも知れません。

実験室で同じ作業を繰り返すのが退屈で非効率なのと同様、コンピュータ・シミュレーションにおいても「単純作業の繰り返し」は人間に向いていません。

そこで次章では、Python のループ機能（`for`文）を使って、この測定プロセスを自動化することにします。
