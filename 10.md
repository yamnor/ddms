---
title: 📕 解説② | 第一原理計算の精度とコスト
---

第一原理計算ソフトは、単に物質名を入力すれば正しい答えが出る魔法の箱ではありません。

正しい結果を得るためには、**「計算精度」と「計算コスト」のトレードオフ** を司る2つの重要なパラメータを適切に設定する必要があります。それが **カットオフエネルギー** と **k点** です。

これらが不適切だと、計算結果は「Garbage In, Garbage Out（ゴミを入れたらゴミが出る）」になります。

## カットオフエネルギー（Cutoff Energy）

周期的な結晶の中では、電子の波動関数を「波（平面波）」の重ね合わせで表現することが一般的です（平面波基底法）。

複雑な形状の関数も、sin や cos の波をたくさん足し合わせれば再現できる（フーリエ級数展開）、という数学的原理に基づいています。

- **定義**: 重ね合わせに使う波のうち、「どこまで細かい波（短波長・高エネルギーの波）まで考慮するか」を決める閾値です。単位は eV（または Ry）で表します。
- **物理的意味**: 空間分解能に相当します。
  - **低い**: ぼやけた粗い画像しか扱えない。原子付近の急峻な変化を記述できない。
  - **高い**: 解像度の高い鮮明な画像を扱える。精度は上がるが、計算に必要なメモリと時間は急増する。

実験のアナロジーで言うと、オシロスコープやAD変換におけるサンプリング周波数のようなものです。

速い信号（急激な変化）を捉えるには高いサンプリングレート（高いカットオフ）が必要ですが、データ量は膨大になります。信号の主要な成分を捉えるのに「十分な」レートを見極める必要があります。

![](https://gyazo.com/f9b09b64c22728ea1042aa05f78a2ef8.jpeg)

## k点サンプリング（k-point sampling）

結晶のような無限に続く周期構造を計算する際、無限個の原子を扱う代わりに、「**逆格子空間（k空間）**」という数学的な空間で積分を行うことで、全体の性質を算出します。

この積分を数値的に行うために、空間内に離散的な点（グリッド）を配置して値をサンプリングします。この点を **k点** と呼びます。

- **表記**: $(N_x, N_y, N_z)$ のように、各軸方向の分割数で指定します。例：`(4, 4, 4)`。
- **物理的意味**: 物質の「平均的な性質」を見積もるための観測点の数です。
  - **金属**: 電子状態がk空間で複雑に変化するため、非常に多くのk点（密なメッシュ）が必要です（例：12x12x12以上）。
  - **絶縁体・半導体**: 比較的少ないk点でも精度が出やすいです（例：4x4x4〜8x8x8）。

身近なもので例えると、国民全体の意見（物質全体のエネルギー）を知るために、何人にアンケート（k点での計算）をとるか、という問題に似ています。

サンプル数が多いほど結果の信頼区間は狭まりますが、調査コストは上がります。傾向が均一な集団（絶縁体）なら少数で済みますが、多様な意見を持つ集団（金属）では多数のサンプルが必要です。

![](https://gyazo.com/60f439d77f6adb556de95191205e8618.jpeg)

## 収束テスト（Convergence Test）

では、具体的に「いくつ」に設定すればよいのでしょうか？

これについては、物質や目的とする精度によって異なり、万能な正解はありません。。そこで、第一原理計算に取り組み始めるときに、必ず **収束テスト** を行います。

1.  **k点を固定し、カットオフを変える**: 300, 400, 500 eV...と上げていき、エネルギーの変化が無視できるレベル（例: 1 meV/atom以下）になった値を探す。
2.  **カットオフを固定し、k点を変える**: (2,2,2), (4,4,4)...と密にしていき、同様に収束判定を行う。隣り合う設定同士の全エネルギー差が、1原子あたり数 meV 以下に収まっていれば、実務上は「十分に収束した」とみなすことが多いです。

この事前作業が、計算データの信頼性を担保する「校正（キャリブレーション）」のプロセスになります。

本講座の実習では、標準的な設定として `PW(350), kpts=(4, 4, 4)` を採用しました。

収束テストの例として Cutoff = 300eV, k = 3x3x3 といった比較的粗い条件からスタートし、徐々に精度を上げて収束テストをおこなってみます。実際には、こうしたテストを経て、自分の系と目的に適した値を決定することになります。

### 実践コード：収束テストの自動化

以下は、GPAWを用いてパラメータを変化させながらエネルギーを計算し、収束挙動を確認するためのコード例です。

**1. カットオフエネルギーの収束テスト**

```python
from ase.build import bulk
from gpaw import GPAW, PW
import numpy as np
import matplotlib.pyplot as plt

atoms = bulk('Si', 'diamond', a=5.43)
cutoff_energies = np.arange(300, 801, 100) # 300 eVから800 eVまで
energies = []

for ecut in cutoff_energies:
    # k点は十分に密な値 (8, 8, 8) に固定して、カットオフだけを変える
    calc = GPAW(mode=PW(ecut), xc='PBE', kpts=(8, 8, 8))
    atoms.set_calculator(calc)
    energies.append(atoms.get_potential_energy())

# 結果のプロット
plt.plot(cutoff_energies, energies, '-o')
plt.xlabel('Cutoff Energy (eV)')
plt.ylabel('Total Energy (eV)')
plt.title('Convergence test: Cutoff Energy')
plt.show()
```

**出力例：**

![](https://gyazo.com/88749905e6d1af7716048283546301a5.png)

**2. k点サンプリングの収束テスト**

```python
k_points = np.arange(2, 11, 2) # 2x2x2 から 10x10x10 まで
energies_k = []

for k in k_points:
    # カットオフは十分に収束した値 (例: 600eV) に固定
    calc = GPAW(mode=PW(600), xc='PBE', kpts=(k, k, k))
    atoms.set_calculator(calc)
    energies_k.append(atoms.get_potential_energy())

# 結果のプロット
plt.plot(k_points, energies_k, '-o')
plt.xlabel('k-point mesh size (N in NxNxN)')
plt.ylabel('Total Energy (eV)')
plt.title('Convergence test: k-points')
plt.show()
```

**出力例：**

![](https://gyazo.com/6db413d377aaa21e5b3fd437c039c430.png)